# Iterating over a Python list

One of the most fundamental types in Python is the list object, which allows a programmer to create lists of objects that can be resized and changed dynamically as the program executes, as opposed to tuples, whose size cannot be changed during execution.

Note that lists can contain a heterogeneous collection of types; as one might expect, the following is valid python:

    a = [1, 2, 3]
    b = ["one", "two", "three"]

But at the same time, we can have a list like this:

    c = [1, "two", 3]

Or even like this, where lists are nested inside one another:

    c = [1, [2], [[3, "three"]]]

At the moment, we are concerned with how exactly a list iterates over its elements, regardless of what they are. Of particular interest is how implementation details are exposed by modifying the list while iterating over it.
In order to expose some of the inner workings of Python lists, let's fix ourselves to the following program:


    x = [1, 2, 3]
    x.append(4)
    for i in x:
        x.remove(i)
    print x


Before continuing onward, go ahead and try to predict what the output of this program will be.

# .
# .
# .

Hard, isn't it? I'll give you a hint, it doesn't give an error like many iterators in C++ do, but has an expected and consistent behavior.

The reason it's difficult is because how the list will behave depends a great deal on the underlying data structure python uses to implement the lists, and how modification happens.

Suppose it used a linked-list sort of structure. Then we would expect the first loop to remove each element of x, one at a time, as the head element is being removed from the linked list.

Now, suppose it uses a fixed array and recreates the whole thing on each modification. Then, we would expect each element of x to be removed because the iterator would take the starting value of the list and iterate over that, oblivious to the fact the list is changing.

As it happens, neither of these are correct. Let's dive in and see what the Python interpreter is actually doing.

The python interpreter compiles the script into the following bytecode:

      1           0 LOAD_CONST               0 (10)
                  3 LOAD_CONST               1 (20)
                  6 LOAD_CONST               2 (30)
                  9 BUILD_LIST               3
                 12 STORE_NAME               0 (x)

      2          15 LOAD_NAME                0 (x)
                 18 LOAD_ATTR                1 (append)
                 21 LOAD_CONST               3 (40)
                 24 CALL_FUNCTION            1
                 27 POP_TOP

      3          28 SETUP_LOOP              27 (to 58)
                 31 LOAD_NAME                0 (x)
                 34 GET_ITER
            >>   35 FOR_ITER                19 (to 57)
                 38 STORE_NAME               2 (i)

      4          41 LOAD_NAME                0 (x)
                 44 LOAD_ATTR                3 (remove)
                 47 LOAD_NAME                2 (i)
                 50 CALL_FUNCTION            1
                 53 POP_TOP
                 54 JUMP_ABSOLUTE           35
            >>   57 POP_BLOCK

      5     >>   58 LOAD_NAME                0 (x)
                 61 PRINT_ITEM
                 62 PRINT_NEWLINE
                 63 LOAD_CONST               4 (None)
                 66 RETURN_VALUE

			 
For the first line, where x is initialized, it isn't hard to see what's going on by eyeballing. The three initial elements of the list, 10, 20, and 30, are loaded from the constants table (which is also generated by the compiler, but isn't shown here), puts the three items on the stack, then creates a list out of them, storing that object into the local variable "x".
At this point, let's skip the loading of constants and storing of values; the only important thing to remember is that the stack is integer objects with values 10 on the bottom, 20 in the middle, and 30 on top, and after execution, a single list object made from these three integer objects.

In the main interpreter loop, the following code handles the list-building instruction:

        case BUILD_LIST:
            x =  PyList_New(oparg);
            if (x != NULL) {
                for (; --oparg >= 0;) {
                    w = POP();
                    PyList_SET_ITEM(x, oparg, w);
                }
                PUSH(x);
                continue;
            }
            break;

			
This begins by calling PyList_New, which allocates a new PyListObject. The physical structure of a PyListObject is this:

    typedef struct {
        PyObject_VAR_HEAD
        /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
        PyObject **ob_item;

        /* ob_item contains space for 'allocated' elements.  The number
         * currently in use is ob_size.
         * Invariants:
         *     0 <= ob_size <= allocated
         *     len(list) == ob_size
         *     ob_item == NULL implies ob_size == allocated == 0
         * list.sort() temporarily sets allocated to -1 to detect mutations.
         *
         * Items must normally not be NULL, except during construction when
         * the list is not yet visible outside the function that builds it.
         */
        Py_ssize_t allocated;
    } PyListObject;

Note that PyObject_VAR_HEAD is defined as follows, in order to maintain a variable-sized list:

    #define PyObject_VAR_HEAD               \
        PyObject_HEAD                       \
        Py_ssize_t ob_size; /* Number of items in variable part */

PyList_New, in addition to allocating this structure, also initializes the pointer array ob_item to contain 3 elements (3 being the argument to PyList_New from the bytecode)
Then, after PyList_New is run, the PyList_SET_ITEM macro (which simply sets the array elements) is used to set the elements of ob_item to PyIntObject pointers with values 10, 20, and 30, respectively.

To implement line 2 of the script, the Python interpreter loads x, loads its "append" attribute, and calls the function with an argument of a PyIntObject with value 40. Since x will have type PyListObject, its append attribute (through a few boilerplate steps skipped) bring us to the app1 method, a simplified version (in other words, a version with all of the error checking removed) of which is below:

    Py_ssize_t n = PyList_GET_SIZE(self);
    list_resize(self, n+1);
    PyList_SET_ITEM(self, n, v);

The list_resize method checks if the required size would exceed the allocated size of ob_item, and if so, the function actually just calls realloc on ob_item, replacing it in-place with an enlarged array (with old elements copied over).

For those of you familiar with C++, this may seem quite familiar: the std::vector class works in a very similar way: pointers to items are kept in a normal array at any given time, but when enough elements are added, the array is resized. It is also worth noting that the allocation size increases exponentially, which has the side-effect that the append operation takes amortized O(1) time, even though each individual add can take up to O(n) time, where n is the number of elements in the list.

Now, the third line of code is where the magic really happens. To repeat from above, the code that actually sets up the for loop is as follows:

    SETUP_LOOP              27 (to 58)
    LOAD_NAME                0 (x)
    GET_ITER
    FOR_ITER                19 (to 57)
    STORE_NAME               2 (i)


Many of you probably remember this block of code from the homework assignment on iterators. As it turns out, almost the exact same thing is happening here as with our Counter class, except that the iter and next methods are different.
To recap, SETUP_LOOP adds a new block to the block stack of the currently executing frame (for our purposes, since there is only one implicit function for the script, this frame is constant throughout execution.) This object's main use, for our purposes, is to remember the current size of the stack, and when the loop is done, since the loop may have leaked many objects onto the stack, remove everything else.
After that point, we put x on top of the stack, and call GET_ITER on it. 
As with our Counter class, as you may recall, GET_ITER looks at the type of x (here it's a PyListObject), and calls the function referenced by the type's tp_iter pointer. For PyListObject, this is the list_iter method, shown below, with extraneous lines removed:

    static PyObject *list_iter(PyObject *seq){
        listiterobject *it;

        it = PyObject_GC_New(listiterobject, &PyListIter_Type);
        it->it_index = 0;
        it->it_seq = (PyListObject *)seq;
        return (PyObject *)it;
    }


What's interesting about this is that the iter method actually creates a new object that iterates over the list, whereas our Counter class just returned itself. A bit of thought should explain why this is the case. What if someone wanted to iterate over the object more than once? Then, the counter would need to be reset each time GET_ITER is called. This may seem fine, but what if someone wanted to nest iteration of a single list, like in the following example which calculates the cartesian product of a list with itself:

	cart = list()
	for a in mylist:
		for b in mylist:
			cart.append((a,b));

If mylist kept track of the iterator's location in itself, this wouldn't work as it would need to contain two different locations at the same time, one corresponding to which element a is, and one corresponding to which element b is.
So, a very thin object of type PyListIter is created, with the following structure:


	typedef struct {
		PyObject_HEAD
		long it_index;
		PyListObject *it_seq; /* Set to NULL when iterator is exhausted */
	} listiterobject;


Additionally, it is this object, rather than the list itself, that implements the next method (that is to say, PyListObject has tp_iternext set to null, while the PyListIter object does have a function.
This function, in fact, is the very core of the list's iteration, a simplified version, with extraneous lines removed, is as follows:

	static PyObject *
	listiter_next(listiterobject *it)
	{
		PyListObject *seq;
		PyObject *item;

		seq = it->it_seq;
		if (seq == NULL)
			return NULL;

		if (it->it_index < PyList_GET_SIZE(seq)) {
			item = PyList_GET_ITEM(seq, it->it_index);
			++it->it_index;
			return item;
		}

		it->it_seq = NULL;
		return NULL;
	}


All this does is simply increment the counter, to indicate that the current position iterated on has increased by one, and if the end of the list has been reached, return null.
One important thing to note here is that it is this method, rather than anything else, that shows what our script will actually do. No matter what actually happens to the PyListObject underneath, the iterator doesn't actually care, it simply increments the index and loads.
In the first part of line 4, where the function remove is called, the function remove is called on the PyListObject x, the simplified code of which is

	for (i = 0; i < Py_SIZE(self); i++) {
		int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);
		if (cmp > 0) {
			list_ass_slice(self, i, i+1, (PyObject *)NULL);
		}
	}

list_ass_slice is a rather complex method, but for this purpose, simply removes the pointer at index i from the ob_item array, and realigns. It has absolutely no effect on any PyListIter objects associated with it.
The rest of the script's implementation is identical to the operation of the Counter class from the previous homework, so I'll gloss over it. Essentially, the end of the loop always jumps right back to FOR_ITER, which calls into the listiter_next method on the PyListIter object we created at the beginning of the loop. When this method returns null, which it does as soon as the stored index exceeds the current size of the referenced PyListObject (i.e. the value of x).
When the loop exits, POP_BLOCK looks at the block we created in SETUP_LOOP, and pops everything that was added to the stack since the beginning of the loop. The rest of the code is just printing out the value of x, which while interesting in its own right, isn't the focus here, and the print line is just used to make the program do something.


So, now that we understand how Python iterates over x, can we predict what the output of this program will be, without running it?
Clearly, x starts the loop with ob_size set to 4 and ob_item a pointer array corresponding to [PyIntObject(10),PyIntObject(20),PyIntObject(30),PyIntObject(40)], and the corresponding PyListIter object pointing to this object with it_index set to 0.
On the first iteration, i points to PyIntObject(10), and it_index is incremented to 1. Then, i will be removed from x, meaning it now has ob_size=3 and a pointer array corresponding to [PyIntObject(20),PyIntObject(30),PyIntObject(40)]. However, this means that 20 is now at position 0, and 30 is at position 1, so the iterator will skip over 20 entirely, pointing i to PyIntObject(30) and setting it_index to 2. When 30 is removed from x, it's ob_size will be only 2, so the loop will exit after that, since it_index is past the end of the list.

Thus, the final value of x is [20, 40], which is the actual printed output of the program.

This is a somewhat surprising answer, and I highly doubt you guessed it at the beginning, but the way list iteration is done in Python, unlike in other languages (Java, for example, will get messed up if you change various List implementations while iterating over it), is totally oblivious to what's actually going on in the list. While this may not be the easiest thing for Python programmers, it's certainly one way for the loop to be totally crash-proof, which in Python, is a must.
